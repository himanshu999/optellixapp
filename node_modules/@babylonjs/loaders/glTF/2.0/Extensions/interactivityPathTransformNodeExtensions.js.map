{"version":3,"file":"interactivityPathTransformNodeExtensions.js","sourceRoot":"","sources":["../../../../../../dev/loaders/src/glTF/2.0/Extensions/interactivityPathTransformNodeExtensions.ts"],"names":[],"mappings":"AAKA,MAAM,UAAU,GAAG,gDAAgD,CAAC;AAEpE,SAAS,uBAAuB,CAAC,IAAmB,EAAE,OAAyB;IAC3E,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;IACrC,MAAM,QAAQ,GAAG,OAAO,CAAC,WAAW,CAAC,MAAM,CAAU,CAAC;IACtD,IAAI,CAAC,QAAQ,EAAE;QACX,MAAM,IAAI,KAAK,CAAC,+BAA+B,QAAQ,EAAE,CAAC,CAAC;KAC9D;IACD,MAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IAC3C,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;QAClC,MAAM,IAAI,KAAK,CAAC,gBAAgB,QAAQ,EAAE,CAAC,CAAC;KAC/C;IACD,MAAM,SAAS,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IACvC,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACzD,IAAI,CAAC,IAAI,EAAE;QACP,MAAM,IAAI,KAAK,CAAC,+BAA+B,QAAQ,EAAE,CAAC,CAAC;KAC9D;IACD,MAAM,WAAW,GAAG,IAAI,CAAC,qBAAsC,CAAC;IAChE,IAAI,CAAC,WAAW,EAAE;QACd,MAAM,IAAI,KAAK,CAAC,kCAAkC,QAAQ,EAAE,CAAC,CAAC;KACjE;IACD,MAAM,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;IAC5B,IAAI,CAAC,QAAQ,EAAE;QACX,MAAM,IAAI,KAAK,CAAC,6BAA6B,QAAQ,EAAE,CAAC,CAAC;KAC5D;IACD,MAAM,eAAe,GAAG,oCAAoC,CAAC,QAAQ,CAAC,CAAC;IACvE,IAAI,CAAC,eAAe,EAAE;QAClB,MAAM,IAAI,KAAK,CAAC,6BAA6B,QAAQ,EAAE,CAAC,CAAC;KAC5D;IACD,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE,CAAC;AAC5C,CAAC;AAED,MAAM,oCAAoC,GAA8B;IACpE,WAAW,EAAE,UAAU;IACvB,KAAK,EAAE,SAAS;IAChB,QAAQ,EAAE,oBAAoB;CACjC,CAAC;AAEF,MAAM,CAAC,MAAM,sBAAsB,GAAmB;IAClD,aAAa,CAAC,IAAmB;QAC7B,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACrC,OAAO,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IACxC,CAAC;IACD,UAAU,CAAC,IAAmB,EAAE,OAAyB;QACrD,MAAM,EAAE,WAAW,EAAE,eAAe,EAAE,GAAG,uBAAuB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAChF,OAAQ,WAAmB,CAAC,eAAe,CAAC,CAAC;IACjD,CAAC;IACD,UAAU,CAAC,IAAmB,EAAE,OAAyB,EAAE,KAAU;QACjE,MAAM,EAAE,WAAW,EAAE,eAAe,EAAE,GAAG,uBAAuB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC/E,WAAmB,CAAC,eAAe,CAAC,GAAG,KAAK,CAAC;IAClD,CAAC;CACJ,CAAC","sourcesContent":["import type { FlowGraphPath, IPathExtension } from \"core/FlowGraph/flowGraphPath\";\r\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\r\nimport type { TransformNode } from \"core/Meshes\";\r\nimport type { IGLTF } from \"../glTFLoaderInterfaces\";\r\n\r\nconst nodesRegex = /^\\/nodes\\/(\\d+)\\/(translation|rotation|scale)$/;\r\n\r\nfunction getBabylonTransformNode(path: FlowGraphPath, context: FlowGraphContext) {\r\n    const fullPath = path.getFinalPath();\r\n    const gltfTree = context.getVariable(\"gltf\") as IGLTF;\r\n    if (!gltfTree) {\r\n        throw new Error(`No glTF tree found for path ${fullPath}`);\r\n    }\r\n    const matches = fullPath.match(nodesRegex);\r\n    if (!matches || matches.length !== 3) {\r\n        throw new Error(`Invalid path ${fullPath}`);\r\n    }\r\n    const nodeIndex = parseInt(matches[1]);\r\n    const node = gltfTree.nodes && gltfTree.nodes[nodeIndex];\r\n    if (!node) {\r\n        throw new Error(`Invalid node index for path ${fullPath}`);\r\n    }\r\n    const babylonNode = node._babylonTransformNode as TransformNode;\r\n    if (!babylonNode) {\r\n        throw new Error(`No Babylon node found for path ${fullPath}`);\r\n    }\r\n    const property = matches[2];\r\n    if (!property) {\r\n        throw new Error(`Invalid property for path ${fullPath}`);\r\n    }\r\n    const babylonProperty = gltfNodePropertyToBabylonPropertyMap[property];\r\n    if (!babylonProperty) {\r\n        throw new Error(`Invalid property for path ${fullPath}`);\r\n    }\r\n    return { babylonNode, babylonProperty };\r\n}\r\n\r\nconst gltfNodePropertyToBabylonPropertyMap: { [key: string]: string } = {\r\n    translation: \"position\",\r\n    scale: \"scaling\",\r\n    rotation: \"rotationQuaternion\",\r\n};\r\n\r\nexport const transformNodeExtension: IPathExtension = {\r\n    shouldProcess(path: FlowGraphPath): boolean {\r\n        const fullPath = path.getFinalPath();\r\n        return !!fullPath.match(nodesRegex);\r\n    },\r\n    processGet(path: FlowGraphPath, context: FlowGraphContext) {\r\n        const { babylonNode, babylonProperty } = getBabylonTransformNode(path, context);\r\n        return (babylonNode as any)[babylonProperty];\r\n    },\r\n    processSet(path: FlowGraphPath, context: FlowGraphContext, value: any) {\r\n        const { babylonNode, babylonProperty } = getBabylonTransformNode(path, context);\r\n        (babylonNode as any)[babylonProperty] = value;\r\n    },\r\n};\r\n"]}