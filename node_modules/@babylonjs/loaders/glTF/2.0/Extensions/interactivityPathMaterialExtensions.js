import { Color3 } from "@babylonjs/core/Maths/math.color.js";
const materialsRegex = /^\/materials\/(\d+)\/(pbrMetallicRoughness\/baseColorFactor|pbrMetallicRoughness\/metallicFactor|pbrMetallicRoughness\/roughnessFactor|alphaCutoff|emissiveFactor|normalTexture\/scale|emissiveTexture\/strength)$/;
const gltfPbrMaterialPropertyToBabylonPropertyMap = {
    "pbrMetallicRoughness/baseColorFactor": "albedoColor",
    "pbrMetallicRoughness/metallicFactor": "metallic",
    "pbrMetallicRoughness/roughnessFactor": "roughness",
    emissiveFactor: "emissiveColor",
};
function getBabylonMaterial(path, context) {
    var _a;
    const fullPath = path.getFinalPath();
    const gltfTree = context.getVariable("gltf");
    if (!gltfTree) {
        throw new Error(`No glTF tree found for path ${fullPath}`);
    }
    const matches = fullPath.match(materialsRegex);
    if (!matches || matches.length !== 3) {
        throw new Error(`Invalid path ${fullPath}`);
    }
    const materialIndex = parseInt(matches[1]);
    const material = gltfTree.materials && gltfTree.materials[materialIndex];
    if (!material) {
        throw new Error(`Invalid material index for path ${fullPath}`);
    }
    const babylonMaterials = [];
    if (!material._data) {
        throw new Error(`No Babylon materials found for path ${fullPath}`);
    }
    for (const data of Object.keys(material._data)) {
        const babylonMaterial = material._data[parseInt(data)].babylonMaterial;
        if (babylonMaterial) {
            babylonMaterials.push(babylonMaterial);
        }
    }
    if (!babylonMaterials || babylonMaterials.length === 0) {
        throw new Error(`No Babylon materials found for path ${fullPath}`);
    }
    const property = matches[2];
    if (!property) {
        throw new Error(`Invalid property for path ${fullPath}`);
    }
    const babylonProperty = (_a = gltfPbrMaterialPropertyToBabylonPropertyMap[property]) !== null && _a !== void 0 ? _a : property;
    return { babylonMaterials, babylonProperty };
}
export const pbrMaterialExtension = {
    shouldProcess(path) {
        const fullPath = path.getFinalPath();
        return !!fullPath.match(materialsRegex);
    },
    processGet(path, context) {
        var _a, _b;
        const { babylonMaterials, babylonProperty } = getBabylonMaterial(path, context);
        /* The difference between the materials is only the drawMode, so we can return the
        property of the first one*/
        if (babylonProperty === "normalTexture/scale") {
            const firstMat = babylonMaterials[0];
            return (_a = firstMat.bumpTexture) === null || _a === void 0 ? void 0 : _a.uScale;
        }
        else if (babylonProperty === "emissiveTexture/strength") {
            const firstMat = babylonMaterials[0];
            return (_b = firstMat.emissiveTexture) === null || _b === void 0 ? void 0 : _b.level;
        }
        else {
            return babylonMaterials[0][babylonProperty];
        }
    },
    processSet(path, context, value) {
        const { babylonMaterials, babylonProperty } = getBabylonMaterial(path, context);
        for (const material of babylonMaterials) {
            if (babylonProperty === "normalTexture/scale") {
                material.bumpTexture.uScale = value;
                material.bumpTexture.vScale = value;
            }
            else if (babylonProperty === "emissiveTexture/strength") {
                material.emissiveTexture.level = value;
            }
            else {
                let finalValue = value;
                if (babylonProperty === "albedoColor" || babylonProperty === "emissiveColor") {
                    finalValue = new Color3(value.x, value.y, value.z);
                }
                material[babylonProperty] = finalValue;
            }
        }
    },
};
//# sourceMappingURL=interactivityPathMaterialExtensions.js.map