{"version":3,"file":"interactivityPathMaterialExtensions.js","sourceRoot":"","sources":["../../../../../../dev/loaders/src/glTF/2.0/Extensions/interactivityPathMaterialExtensions.ts"],"names":[],"mappings":"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","sourcesContent":["import type { FlowGraphPath } from \"core/FlowGraph/flowGraphPath\";\r\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\r\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IGLTF } from \"../glTFLoaderInterfaces\";\r\n\r\nconst materialsRegex =\r\n    /^\\/materials\\/(\\d+)\\/(pbrMetallicRoughness\\/baseColorFactor|pbrMetallicRoughness\\/metallicFactor|pbrMetallicRoughness\\/roughnessFactor|alphaCutoff|emissiveFactor|normalTexture\\/scale|emissiveTexture\\/strength)$/;\r\n\r\nconst gltfPbrMaterialPropertyToBabylonPropertyMap: { [key: string]: string } = {\r\n    \"pbrMetallicRoughness/baseColorFactor\": \"albedoColor\",\r\n    \"pbrMetallicRoughness/metallicFactor\": \"metallic\",\r\n    \"pbrMetallicRoughness/roughnessFactor\": \"roughness\",\r\n    emissiveFactor: \"emissiveColor\",\r\n};\r\n\r\nfunction getBabylonMaterial(path: FlowGraphPath, context: FlowGraphContext) {\r\n    const fullPath = path.getFinalPath();\r\n    const gltfTree = context.getVariable(\"gltf\") as IGLTF;\r\n    if (!gltfTree) {\r\n        throw new Error(`No glTF tree found for path ${fullPath}`);\r\n    }\r\n    const matches = fullPath.match(materialsRegex);\r\n    if (!matches || matches.length !== 3) {\r\n        throw new Error(`Invalid path ${fullPath}`);\r\n    }\r\n    const materialIndex = parseInt(matches[1]);\r\n    const material = gltfTree.materials && gltfTree.materials[materialIndex];\r\n    if (!material) {\r\n        throw new Error(`Invalid material index for path ${fullPath}`);\r\n    }\r\n    const babylonMaterials = [];\r\n    if (!material._data) {\r\n        throw new Error(`No Babylon materials found for path ${fullPath}`);\r\n    }\r\n    for (const data of Object.keys(material._data)) {\r\n        const babylonMaterial = material._data[parseInt(data)].babylonMaterial as PBRMaterial;\r\n        if (babylonMaterial) {\r\n            babylonMaterials.push(babylonMaterial);\r\n        }\r\n    }\r\n    if (!babylonMaterials || babylonMaterials.length === 0) {\r\n        throw new Error(`No Babylon materials found for path ${fullPath}`);\r\n    }\r\n    const property = matches[2];\r\n    if (!property) {\r\n        throw new Error(`Invalid property for path ${fullPath}`);\r\n    }\r\n    const babylonProperty = gltfPbrMaterialPropertyToBabylonPropertyMap[property] ?? property;\r\n    return { babylonMaterials, babylonProperty };\r\n}\r\n\r\nexport const pbrMaterialExtension = {\r\n    shouldProcess(path: FlowGraphPath): boolean {\r\n        const fullPath = path.getFinalPath();\r\n        return !!fullPath.match(materialsRegex);\r\n    },\r\n    processGet(path: FlowGraphPath, context: FlowGraphContext): any {\r\n        const { babylonMaterials, babylonProperty } = getBabylonMaterial(path, context);\r\n        /* The difference between the materials is only the drawMode, so we can return the\r\n        property of the first one*/\r\n        if (babylonProperty === \"normalTexture/scale\") {\r\n            const firstMat = babylonMaterials[0];\r\n            return (firstMat.bumpTexture as Texture)?.uScale;\r\n        } else if (babylonProperty === \"emissiveTexture/strength\") {\r\n            const firstMat = babylonMaterials[0];\r\n            return firstMat.emissiveTexture?.level;\r\n        } else {\r\n            return (babylonMaterials[0] as any)[babylonProperty];\r\n        }\r\n    },\r\n    processSet(path: FlowGraphPath, context: FlowGraphContext, value: any) {\r\n        const { babylonMaterials, babylonProperty } = getBabylonMaterial(path, context);\r\n        for (const material of babylonMaterials) {\r\n            if (babylonProperty === \"normalTexture/scale\") {\r\n                (material.bumpTexture as Texture).uScale = value;\r\n                (material.bumpTexture as Texture).vScale = value;\r\n            } else if (babylonProperty === \"emissiveTexture/strength\") {\r\n                material.emissiveTexture!.level = value;\r\n            } else {\r\n                let finalValue = value;\r\n                if (babylonProperty === \"albedoColor\" || babylonProperty === \"emissiveColor\") {\r\n                    finalValue = new Color3(value.x, value.y, value.z);\r\n                }\r\n                (material as any)[babylonProperty] = finalValue;\r\n            }\r\n        }\r\n    },\r\n};\r\n"]}