const nodesRegex = /^\/nodes\/(\d+)\/(translation|rotation|scale)$/;
function getBabylonTransformNode(path, context) {
    const fullPath = path.getFinalPath();
    const gltfTree = context.getVariable("gltf");
    if (!gltfTree) {
        throw new Error(`No glTF tree found for path ${fullPath}`);
    }
    const matches = fullPath.match(nodesRegex);
    if (!matches || matches.length !== 3) {
        throw new Error(`Invalid path ${fullPath}`);
    }
    const nodeIndex = parseInt(matches[1]);
    const node = gltfTree.nodes && gltfTree.nodes[nodeIndex];
    if (!node) {
        throw new Error(`Invalid node index for path ${fullPath}`);
    }
    const babylonNode = node._babylonTransformNode;
    if (!babylonNode) {
        throw new Error(`No Babylon node found for path ${fullPath}`);
    }
    const property = matches[2];
    if (!property) {
        throw new Error(`Invalid property for path ${fullPath}`);
    }
    const babylonProperty = gltfNodePropertyToBabylonPropertyMap[property];
    if (!babylonProperty) {
        throw new Error(`Invalid property for path ${fullPath}`);
    }
    return { babylonNode, babylonProperty };
}
const gltfNodePropertyToBabylonPropertyMap = {
    translation: "position",
    scale: "scaling",
    rotation: "rotationQuaternion",
};
export const transformNodeExtension = {
    shouldProcess(path) {
        const fullPath = path.getFinalPath();
        return !!fullPath.match(nodesRegex);
    },
    processGet(path, context) {
        const { babylonNode, babylonProperty } = getBabylonTransformNode(path, context);
        return babylonNode[babylonProperty];
    },
    processSet(path, context, value) {
        const { babylonNode, babylonProperty } = getBabylonTransformNode(path, context);
        babylonNode[babylonProperty] = value;
    },
};
//# sourceMappingURL=interactivityPathTransformNodeExtensions.js.map