import { GLTFLoader } from "../glTFLoader.js";
import { FlowGraphCoordinator } from "@babylonjs/core/FlowGraph/flowGraphCoordinator.js";
import { FlowGraph } from "@babylonjs/core/FlowGraph/flowGraph.js";
import { FlowGraphPath } from "@babylonjs/core/FlowGraph/flowGraphPath.js";
import { convertGLTFToSerializedFlowGraph } from "./interactivityFunctions.js";
import { interactivityPathExensions } from "./interactivityPathExtensions.js";
const NAME = "KHR_interactivity";
/**
 * Loader extension for KHR_interactivity
 */
export class KHR_interactivity {
    /**
     * @internal
     * @param _loader
     */
    constructor(_loader) {
        this._loader = _loader;
        /**
         * The name of this extension.
         */
        this.name = NAME;
        this.enabled = this._loader.isExtensionUsed(NAME);
    }
    dispose() {
        this._loader = null;
    }
    onReady() {
        var _a;
        if (!this._loader.babylonScene) {
            return;
        }
        const scene = this._loader.babylonScene;
        const definition = (_a = this._loader.gltf.extensions) === null || _a === void 0 ? void 0 : _a.KHR_interactivity;
        // Fill out the array of extensions that the FlowGraphPath can use
        for (const extension of interactivityPathExensions) {
            if (!FlowGraphPath.Extensions.includes(extension)) {
                FlowGraphPath.Extensions.push(extension);
            }
        }
        const json = convertGLTFToSerializedFlowGraph(definition);
        const coordinator = new FlowGraphCoordinator({ scene });
        const graph = FlowGraph.Parse(json, coordinator);
        const context = graph.getContext(0);
        context.setVariable("gltf", this._loader.gltf);
        coordinator.start();
    }
}
GLTFLoader.RegisterExtension(NAME, (loader) => new KHR_interactivity(loader));
//# sourceMappingURL=KHR_interactivity.js.map