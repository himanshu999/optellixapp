import { RegisterClass } from "../Misc/typeStore.js";
// Path: /x/{y}/z/.../w
const PATH_REGEX = /([./])({?\w+}?)/g;
/*
 * @experimental
 * This class represents a path of type /x/{y}/z/.../w that is evaluated
 * on a target object. The string between curly braces ({y} in the example)
 * is a special template string that is replaced during runtime.
 */
export class FlowGraphPath {
    constructor(path) {
        this._templateSubstitutions = {}; // this is a map of template strings to values that are substituted during runtime
        this._pathParts = []; // this is the path divided into parts, with each part being either a template string or a regular string
        this._templateStrings = []; // this is the list of template strings in the path
        /**
         * Whether this path has any template strings in it.
         */
        this.hasTemplateStrings = false;
        this._path = path;
        const { pathParts, templateStrings } = this._getPathPartsAndTemplateStrings(path);
        this._pathParts = pathParts;
        this._templateStrings = templateStrings;
        this.hasTemplateStrings = templateStrings.length > 0;
    }
    _getPathPartsAndTemplateStrings(path) {
        const allMatches = path.matchAll(PATH_REGEX);
        const pathParts = [];
        const templateStrings = [];
        let nextMatch = allMatches.next();
        while (!nextMatch.done) {
            const singleMatch = nextMatch.value;
            const [, separator, value] = singleMatch;
            let valueWithoutBraces = value;
            let isTemplate = false;
            if (value.startsWith("{") && value.endsWith("}")) {
                isTemplate = true;
                valueWithoutBraces = value.slice(1, value.length - 1);
                if (templateStrings.indexOf(valueWithoutBraces) === -1) {
                    templateStrings.push(valueWithoutBraces);
                }
            }
            pathParts.push({
                value,
                isTemplate,
                valueWithoutBraces,
                separator,
            });
            nextMatch = allMatches.next();
        }
        return { pathParts, templateStrings };
    }
    /**
     * Gets the template strings in this path.
     * @returns an array containing the template strings in this path.
     */
    getTemplateStrings() {
        return this._templateStrings;
    }
    setTemplateSubstitution(template, value) {
        if (this._templateStrings.indexOf(template) === -1) {
            throw new Error(`Template string ${template} does not exist in path ${this._path}`);
        }
        this._templateSubstitutions[template] = value;
    }
    _evaluateTemplates() {
        for (const pathPart of this._pathParts) {
            if (pathPart.isTemplate) {
                const value = this._templateSubstitutions[pathPart.valueWithoutBraces];
                if (value === undefined) {
                    throw new Error(`Template string ${pathPart.value} was not substituted`);
                }
                pathPart.replacedValue = value.toString();
            }
        }
    }
    /**
     * Gets the final path after all template strings have been substituted.
     * @returns a string representing the final path.
     */
    getFinalPath() {
        let finalPath = "";
        for (const pathPart of this._pathParts) {
            finalPath += pathPart.separator;
            if (pathPart.isTemplate) {
                finalPath += pathPart.replacedValue;
            }
            else {
                finalPath += pathPart.value;
            }
        }
        return finalPath;
    }
    /*
     * Breaks the path into a chain of entities, for example,
     * /x/y/z would be split into [context._userVariables.x, context._userVariables.x.y, context._userVariables.x.y.z],
     * and the path that was split, i.e. /x/y/z, would be split into ["x", "y", "z"].
     */
    _evaluatePath(context) {
        this._evaluateTemplates();
        const entityChain = [];
        const splitPath = [];
        let currentTarget = context.userVariables;
        for (const pathPart of this._pathParts) {
            if (currentTarget === undefined) {
                throw new Error(`Could not find path ${this.getFinalPath()} in target context`);
            }
            const value = pathPart.isTemplate ? pathPart.replacedValue : pathPart.value;
            if (!value) {
                throw new Error(`Invalid path ${this.getFinalPath()}`);
            }
            currentTarget = currentTarget[value];
            entityChain.push(currentTarget);
            splitPath.push(value);
        }
        return { entityChain, splitPath };
    }
    getProperty(context) {
        for (const extension of FlowGraphPath.Extensions) {
            if (extension.shouldProcess(this)) {
                return extension.processGet(this, context);
            }
        }
        const { entityChain } = this._evaluatePath(context);
        return entityChain[entityChain.length - 1];
    }
    setProperty(context, value) {
        for (const extension of FlowGraphPath.Extensions) {
            if (extension.shouldProcess(this)) {
                extension.processSet(this, context, value);
                return;
            }
        }
        const { entityChain, splitPath } = this._evaluatePath(context);
        const target = entityChain[entityChain.length - 2];
        const property = splitPath[splitPath.length - 1];
        target[property] = value;
    }
    getClassName() {
        return FlowGraphPath.ClassName;
    }
    serialize(serializationObject = {}) {
        serializationObject.path = this._path;
        serializationObject.className = this.getClassName();
        return serializationObject;
    }
    static Parse(serializationObject) {
        return new FlowGraphPath(serializationObject.path);
    }
}
/**
 * Extensions that can be used to extend the functionality of the path.
 */
FlowGraphPath.Extensions = [];
FlowGraphPath.ClassName = "FGPath";
RegisterClass(FlowGraphPath.ClassName, FlowGraphPath);
//# sourceMappingURL=flowGraphPath.js.map