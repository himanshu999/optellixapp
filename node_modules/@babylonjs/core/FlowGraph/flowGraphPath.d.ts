import type { FlowGraphContext } from "./flowGraphContext";
/**
 * @experimental
 * An extension to add new functionality to path resolution
 */
export interface IPathExtension {
    shouldProcess(path: FlowGraphPath): boolean;
    processGet(path: FlowGraphPath, context: FlowGraphContext): any;
    processSet(path: FlowGraphPath, context: FlowGraphContext, value: any): void;
}
export declare class FlowGraphPath {
    /**
     * Extensions that can be used to extend the functionality of the path.
     */
    static Extensions: IPathExtension[];
    private _path;
    private _templateSubstitutions;
    private _pathParts;
    private _templateStrings;
    /**
     * Whether this path has any template strings in it.
     */
    hasTemplateStrings: boolean;
    constructor(path: string);
    private _getPathPartsAndTemplateStrings;
    /**
     * Gets the template strings in this path.
     * @returns an array containing the template strings in this path.
     */
    getTemplateStrings(): string[];
    setTemplateSubstitution(template: string, value: number): void;
    private _evaluateTemplates;
    /**
     * Gets the final path after all template strings have been substituted.
     * @returns a string representing the final path.
     */
    getFinalPath(): string;
    private _evaluatePath;
    getProperty(context: FlowGraphContext): any;
    setProperty(context: FlowGraphContext, value: any): void;
    getClassName(): string;
    serialize(serializationObject?: any): any;
    static Parse(serializationObject: any): FlowGraphPath;
    static ClassName: string;
}
