{"version":3,"file":"flowGraphPath.js","sourceRoot":"","sources":["../../../../dev/core/src/FlowGraph/flowGraphPath.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,mBAAmB,CAAC;AAGlD,uBAAuB;AACvB,MAAM,UAAU,GAAG,kBAAkB,CAAC;AAoBtC;;;;;GAKG;AACH,MAAM,OAAO,aAAa;IAiBtB,YAAY,IAAY;QAVhB,2BAAsB,GAE1B,EAAE,CAAC,CAAC,kFAAkF;QAClF,eAAU,GAAgB,EAAE,CAAC,CAAC,yGAAyG;QACvI,qBAAgB,GAAa,EAAE,CAAC,CAAC,mDAAmD;QAC5F;;WAEG;QACI,uBAAkB,GAAY,KAAK,CAAC;QAGvC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,MAAM,EAAE,SAAS,EAAE,eAAe,EAAE,GAAG,IAAI,CAAC,+BAA+B,CAAC,IAAI,CAAC,CAAC;QAClF,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;QACxC,IAAI,CAAC,kBAAkB,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC;IACzD,CAAC;IAEO,+BAA+B,CAAC,IAAY;QAChD,MAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAE7C,MAAM,SAAS,GAAG,EAAE,CAAC;QACrB,MAAM,eAAe,GAAG,EAAE,CAAC;QAC3B,IAAI,SAAS,GAAG,UAAU,CAAC,IAAI,EAAE,CAAC;QAClC,OAAO,CAAC,SAAS,CAAC,IAAI,EAAE;YACpB,MAAM,WAAW,GAAG,SAAS,CAAC,KAAK,CAAC;YACpC,MAAM,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,GAAG,WAAW,CAAC;YACzC,IAAI,kBAAkB,GAAG,KAAK,CAAC;YAC/B,IAAI,UAAU,GAAG,KAAK,CAAC;YACvB,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBAC9C,UAAU,GAAG,IAAI,CAAC;gBAClB,kBAAkB,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBACtD,IAAI,eAAe,CAAC,OAAO,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,EAAE;oBACpD,eAAe,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;iBAC5C;aACJ;YACD,SAAS,CAAC,IAAI,CAAC;gBACX,KAAK;gBACL,UAAU;gBACV,kBAAkB;gBAClB,SAAS;aACZ,CAAC,CAAC;YACH,SAAS,GAAG,UAAU,CAAC,IAAI,EAAE,CAAC;SACjC;QACD,OAAO,EAAE,SAAS,EAAE,eAAe,EAAE,CAAC;IAC1C,CAAC;IAED;;;OAGG;IACH,kBAAkB;QACd,OAAO,IAAI,CAAC,gBAAgB,CAAC;IACjC,CAAC;IAED,uBAAuB,CAAC,QAAgB,EAAE,KAAa;QACnD,IAAI,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;YAChD,MAAM,IAAI,KAAK,CAAC,mBAAmB,QAAQ,2BAA2B,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;SACvF;QACD,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;IAClD,CAAC;IAEO,kBAAkB;QACtB,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,EAAE;YACpC,IAAI,QAAQ,CAAC,UAAU,EAAE;gBACrB,MAAM,KAAK,GAAG,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,kBAAkB,CAAC,CAAC;gBACvE,IAAI,KAAK,KAAK,SAAS,EAAE;oBACrB,MAAM,IAAI,KAAK,CAAC,mBAAmB,QAAQ,CAAC,KAAK,sBAAsB,CAAC,CAAC;iBAC5E;gBACD,QAAQ,CAAC,aAAa,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;aAC7C;SACJ;IACL,CAAC;IAED;;;OAGG;IACI,YAAY;QACf,IAAI,SAAS,GAAG,EAAE,CAAC;QACnB,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,EAAE;YACpC,SAAS,IAAI,QAAQ,CAAC,SAAS,CAAC;YAChC,IAAI,QAAQ,CAAC,UAAU,EAAE;gBACrB,SAAS,IAAI,QAAQ,CAAC,aAAa,CAAC;aACvC;iBAAM;gBACH,SAAS,IAAI,QAAQ,CAAC,KAAK,CAAC;aAC/B;SACJ;QACD,OAAO,SAAS,CAAC;IACrB,CAAC;IAED;;;;OAIG;IACK,aAAa,CAAC,OAAyB;QAC3C,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAE1B,MAAM,WAAW,GAAG,EAAE,CAAC;QACvB,MAAM,SAAS,GAAG,EAAE,CAAC;QACrB,IAAI,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;QAC1C,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,EAAE;YACpC,IAAI,aAAa,KAAK,SAAS,EAAE;gBAC7B,MAAM,IAAI,KAAK,CAAC,uBAAuB,IAAI,CAAC,YAAY,EAAE,oBAAoB,CAAC,CAAC;aACnF;YACD,MAAM,KAAK,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC;YAC5E,IAAI,CAAC,KAAK,EAAE;gBACR,MAAM,IAAI,KAAK,CAAC,gBAAgB,IAAI,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;aAC1D;YACD,aAAa,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC;YACrC,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAChC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACzB;QAED,OAAO,EAAE,WAAW,EAAE,SAAS,EAAE,CAAC;IACtC,CAAC;IAED,WAAW,CAAC,OAAyB;QACjC,KAAK,MAAM,SAAS,IAAI,aAAa,CAAC,UAAU,EAAE;YAC9C,IAAI,SAAS,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE;gBAC/B,OAAO,SAAS,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;aAC9C;SACJ;QACD,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QACpD,OAAO,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAC/C,CAAC;IAED,WAAW,CAAC,OAAyB,EAAE,KAAU;QAC7C,KAAK,MAAM,SAAS,IAAI,aAAa,CAAC,UAAU,EAAE;YAC9C,IAAI,SAAS,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE;gBAC/B,SAAS,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;gBAC3C,OAAO;aACV;SACJ;QACD,MAAM,EAAE,WAAW,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAC/D,MAAM,MAAM,GAAG,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACnD,MAAM,QAAQ,GAAG,SAAS,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACjD,MAAM,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;IAC7B,CAAC;IAED,YAAY;QACR,OAAO,aAAa,CAAC,SAAS,CAAC;IACnC,CAAC;IAED,SAAS,CAAC,sBAA2B,EAAE;QACnC,mBAAmB,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;QACtC,mBAAmB,CAAC,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACpD,OAAO,mBAAmB,CAAC;IAC/B,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,mBAAwB;QACjC,OAAO,IAAI,aAAa,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;;AA/JD;;GAEG;AACI,wBAAU,GAAqB,EAAE,AAAvB,CAAwB;AA8J3B,uBAAS,GAAG,QAAQ,AAAX,CAAY;AAEvC,aAAa,CAAC,aAAa,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC","sourcesContent":["import { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\n\r\n// Path: /x/{y}/z/.../w\r\nconst PATH_REGEX = /([./])({?\\w+}?)/g;\r\n\r\ninterface IPathPart {\r\n    value: string;\r\n    isTemplate: boolean;\r\n    valueWithoutBraces: string;\r\n    replacedValue?: string;\r\n    separator: string;\r\n}\r\n\r\n/**\r\n * @experimental\r\n * An extension to add new functionality to path resolution\r\n */\r\nexport interface IPathExtension {\r\n    shouldProcess(path: FlowGraphPath): boolean;\r\n    processGet(path: FlowGraphPath, context: FlowGraphContext): any;\r\n    processSet(path: FlowGraphPath, context: FlowGraphContext, value: any): void;\r\n}\r\n\r\n/*\r\n * @experimental\r\n * This class represents a path of type /x/{y}/z/.../w that is evaluated\r\n * on a target object. The string between curly braces ({y} in the example)\r\n * is a special template string that is replaced during runtime.\r\n */\r\nexport class FlowGraphPath {\r\n    /**\r\n     * Extensions that can be used to extend the functionality of the path.\r\n     */\r\n    static Extensions: IPathExtension[] = [];\r\n\r\n    private _path: string;\r\n    private _templateSubstitutions: {\r\n        [key: string]: number;\r\n    } = {}; // this is a map of template strings to values that are substituted during runtime\r\n    private _pathParts: IPathPart[] = []; // this is the path divided into parts, with each part being either a template string or a regular string\r\n    private _templateStrings: string[] = []; // this is the list of template strings in the path\r\n    /**\r\n     * Whether this path has any template strings in it.\r\n     */\r\n    public hasTemplateStrings: boolean = false;\r\n\r\n    constructor(path: string) {\r\n        this._path = path;\r\n        const { pathParts, templateStrings } = this._getPathPartsAndTemplateStrings(path);\r\n        this._pathParts = pathParts;\r\n        this._templateStrings = templateStrings;\r\n        this.hasTemplateStrings = templateStrings.length > 0;\r\n    }\r\n\r\n    private _getPathPartsAndTemplateStrings(path: string) {\r\n        const allMatches = path.matchAll(PATH_REGEX);\r\n\r\n        const pathParts = [];\r\n        const templateStrings = [];\r\n        let nextMatch = allMatches.next();\r\n        while (!nextMatch.done) {\r\n            const singleMatch = nextMatch.value;\r\n            const [, separator, value] = singleMatch;\r\n            let valueWithoutBraces = value;\r\n            let isTemplate = false;\r\n            if (value.startsWith(\"{\") && value.endsWith(\"}\")) {\r\n                isTemplate = true;\r\n                valueWithoutBraces = value.slice(1, value.length - 1);\r\n                if (templateStrings.indexOf(valueWithoutBraces) === -1) {\r\n                    templateStrings.push(valueWithoutBraces);\r\n                }\r\n            }\r\n            pathParts.push({\r\n                value,\r\n                isTemplate,\r\n                valueWithoutBraces,\r\n                separator,\r\n            });\r\n            nextMatch = allMatches.next();\r\n        }\r\n        return { pathParts, templateStrings };\r\n    }\r\n\r\n    /**\r\n     * Gets the template strings in this path.\r\n     * @returns an array containing the template strings in this path.\r\n     */\r\n    getTemplateStrings(): string[] {\r\n        return this._templateStrings;\r\n    }\r\n\r\n    setTemplateSubstitution(template: string, value: number) {\r\n        if (this._templateStrings.indexOf(template) === -1) {\r\n            throw new Error(`Template string ${template} does not exist in path ${this._path}`);\r\n        }\r\n        this._templateSubstitutions[template] = value;\r\n    }\r\n\r\n    private _evaluateTemplates() {\r\n        for (const pathPart of this._pathParts) {\r\n            if (pathPart.isTemplate) {\r\n                const value = this._templateSubstitutions[pathPart.valueWithoutBraces];\r\n                if (value === undefined) {\r\n                    throw new Error(`Template string ${pathPart.value} was not substituted`);\r\n                }\r\n                pathPart.replacedValue = value.toString();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the final path after all template strings have been substituted.\r\n     * @returns a string representing the final path.\r\n     */\r\n    public getFinalPath() {\r\n        let finalPath = \"\";\r\n        for (const pathPart of this._pathParts) {\r\n            finalPath += pathPart.separator;\r\n            if (pathPart.isTemplate) {\r\n                finalPath += pathPart.replacedValue;\r\n            } else {\r\n                finalPath += pathPart.value;\r\n            }\r\n        }\r\n        return finalPath;\r\n    }\r\n\r\n    /*\r\n     * Breaks the path into a chain of entities, for example,\r\n     * /x/y/z would be split into [context._userVariables.x, context._userVariables.x.y, context._userVariables.x.y.z],\r\n     * and the path that was split, i.e. /x/y/z, would be split into [\"x\", \"y\", \"z\"].\r\n     */\r\n    private _evaluatePath(context: FlowGraphContext): { entityChain: any[]; splitPath: string[] } {\r\n        this._evaluateTemplates();\r\n\r\n        const entityChain = [];\r\n        const splitPath = [];\r\n        let currentTarget = context.userVariables;\r\n        for (const pathPart of this._pathParts) {\r\n            if (currentTarget === undefined) {\r\n                throw new Error(`Could not find path ${this.getFinalPath()} in target context`);\r\n            }\r\n            const value = pathPart.isTemplate ? pathPart.replacedValue : pathPart.value;\r\n            if (!value) {\r\n                throw new Error(`Invalid path ${this.getFinalPath()}`);\r\n            }\r\n            currentTarget = currentTarget[value];\r\n            entityChain.push(currentTarget);\r\n            splitPath.push(value);\r\n        }\r\n\r\n        return { entityChain, splitPath };\r\n    }\r\n\r\n    getProperty(context: FlowGraphContext): any {\r\n        for (const extension of FlowGraphPath.Extensions) {\r\n            if (extension.shouldProcess(this)) {\r\n                return extension.processGet(this, context);\r\n            }\r\n        }\r\n        const { entityChain } = this._evaluatePath(context);\r\n        return entityChain[entityChain.length - 1];\r\n    }\r\n\r\n    setProperty(context: FlowGraphContext, value: any) {\r\n        for (const extension of FlowGraphPath.Extensions) {\r\n            if (extension.shouldProcess(this)) {\r\n                extension.processSet(this, context, value);\r\n                return;\r\n            }\r\n        }\r\n        const { entityChain, splitPath } = this._evaluatePath(context);\r\n        const target = entityChain[entityChain.length - 2];\r\n        const property = splitPath[splitPath.length - 1];\r\n        target[property] = value;\r\n    }\r\n\r\n    getClassName() {\r\n        return FlowGraphPath.ClassName;\r\n    }\r\n\r\n    serialize(serializationObject: any = {}) {\r\n        serializationObject.path = this._path;\r\n        serializationObject.className = this.getClassName();\r\n        return serializationObject;\r\n    }\r\n\r\n    static Parse(serializationObject: any) {\r\n        return new FlowGraphPath(serializationObject.path);\r\n    }\r\n\r\n    public static ClassName = \"FGPath\";\r\n}\r\nRegisterClass(FlowGraphPath.ClassName, FlowGraphPath);\r\n"]}